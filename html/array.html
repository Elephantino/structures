<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>array</title>
  <link rel="stylesheet" href="../style.css">
  <link rel="shortcut icon" href="img/window-icon/window-icon.png" type="image/png">
</head>

<body>
  <div class="wrapper">

  <div class="wrapper">
	<header class="page-header">
		<div class="container">
			<a href="../index.html">home</a>
		</div>
	</header>

    <main class="page--main">
      <div class="container">

<section class="array">

<h1>array</h1>

<ul>
                    <li>списки пронумерованных значений</li>
                    <li>могут содержать данные любого типа</li>
                    <li>многие методы массива будут влиять на исходный массив, а не на его копию</li>
                  </ul>
                  <pre>
  <code>
const a = []
const a = [1, 2, 3]
const a = Array.of(1, 2, 3)
const a = Array(6).fill(1) // 6 элементов c числом 1
</code>
</pre>
                  <h3>Доступ к элементам по индексам arr[index]</h3>
                  <pre>
   <code>
let arr = [10, "2", 3, false];
let first = arr[0];
let count = 1;

arr[0] и arr.at(0) оба вернут первый элемент

console.log(arr[3]); // false
console.log(first); // 10
console.log(arr[count]) // "2"
  </code>
</pre>

                  <p>При использовании точки слово, стоящее после нее, является точечным именем свойства.</p>
                  <p>При использовании квадратных скобок,для получении имени свойства
                    <i>Вычисляется</i> заключенное в скобки выражение.
                  </p>
                  <p>Если value.x извлекает из значения value свойство с именем x, то
                    value[x] пытается вычислить выражение x и применяет результат, преобразованный в строку, в
                    качестве
                    имени
                    свойства</p>
                  <p>По этому если вы знаете что интересующее вас свойство называется color, то пишите сразу
                    value.color
                  </p>
				  
                  <details class="show-piece">
                    <summary><code>сортировка массива</code></summary>
                    <textarea cols="120" rows="28">
let arr = [4, 1, 3, 2, 5];

console.log(arr);

for (let currentIndex = 0; currentIndex &lt;= arr.length - 2; currentIndex++) {

  let minValue = arr[currentIndex];

  for (let j = currentIndex + 1; j &lt;= arr.length - 1; j++) {

    if(arr[j] &lt; minValue) {

      minValue = arr[j];

      let swap = arr[currentIndex];

      arr[currentIndex] = minValue;

      arr[j] = swap;

      console.log('меняем местами ' + swap + ' и ' + minValue);
      console.log('Массив сейчас: ' + arr);
    }
  }
  console.log('на позиции ' + currentIndex + ' находится минимальный элемент ' + minValue);
}
console.log(arr);
        </textarea>

                  </details>
				  
<div><!-- replacement -->
                    <h3>replacement</h3>
                    <pre>
   <code>
arr[0] = 4
console.log(a) //[4, "2", 3, false];
   </code>
</pre>

                    <h3>add</h3>
                    <pre>
  <code>
a[5] = false;
console.log(arr) //[ 4, "2", 3, false "", false ] // Разреженный массив
  </code>
</pre>

                    <h3>Обращение к несуществующему элементу вернет undefined</h3>
                    <pre>
   <code>
console.log(arr[7]); // undefined
   </code>
</pre>

                    <h2>меняем элементы массива местами</h2>
                    <pre>
    <code>
let a = [4, 1, 2, 3];
let swap = a[0];

a[1] = swap; // [1, 4, 2, 3]
    </code>
</pre>
                    <p>если сразу записать на первое место значение второго элемента, то мы потеряем значение первого.
                    </p>


                    <div>
                      <p>matches() //проверка</p>
                      <p>closet() //возвращает</p>
                      <p>contains() //проверка</p>
                    </div>
                  </div>	  
				  
				  
<details class="show-piece array-clone">
                    <summary>Клонирование массива</summary>
                    <p>В js нет метода для клонирования массивов</p>
                    <p>Этот метод легко сэмулировать, помня, что concat и slice не меняют исходный массив. Достаточно
                      вызвать
                      метод
                      concat без
                      аргументов или метод slice с единственным аргументом равным 0.</p>
                    <pre>
   <code>
let a = [1,2,3];
let b = a.concat();
let c = a.slice(0);

(a + ';' + b + ';' + c); // '1,2,3;1,2,3;1,2,3'

([a == b, a == c, b == c]); // [ false,false,false ]
   </code>
</pre>
                    <p>Если в массиве лежат ссылки на объекты, в том числе ссылки на другие массивы, то в
                      новосозданном
                      массиве будут лежать
                      ссылки на те же самые объекты. Поэтому если вы хотите клонировать многомерный массив, то
                      придётся
                      вручную создавать
                      новый массив, после чего перебрать подмассивы исходного массива и клонировать их в новый.</p>
                    <pre>
   <code>
  Клонируется только массив верхнего уровня:
let a = [
[1,2,3],
[4,5,6],
[7,8,9]
];

let b = a.concat();

a[0][1] // 2
b[0][1] // 2

b[0][1] = 15;
a[0][1] // 15
   </code>
</pre>
                    <pre>
   <code>
  Клонируем вложенные массивы:

let a = [
[1,2,3],
[4,5,6],
[7,8,9]
];

let b = [ ];
  a.forEach(function(subArry) {
  b.push(subArray.concat());
})

a[0][1]; // 2
b[0][1]; // 2

b[0][1] = 15;
a[0][1]; // 15
   </code>
</pre>


                  </details>				  
				  
			
<div class="performance">
                    <h3>перебор массива</h3>

                    <h3>for</h3>
                    <pre><code>
let arr = [ "a", "b", "c", "d" ];

for (let <span class="color-red">i</span> = 0; i < arr.length; i++) {                
  console.log(i + " - " + arr[i]);             в цикле for переменная <span class="color-red">i</span> - никак к ключу не 
};                                                относится это просто переменная которая 
          i      arr[i]                              изменяется каждую итерацию цикла,
      // ключ - значение                                в других циклах <span class="color-red">i</span> это ключ/свойство
            0 - a
            1 - b
            2 - c
            3 - d

</code></pre>

                    <h3>for in</h3>
                    <p class="color-red">for in не стоит использовать для перебора массива</p>
                    <pre><code>
let arr = [ "a", "b", "c", "d" ];

for (let <span class="color-red">i</span> <span class="color-light-blue">in</span> arr) {  
  console.log(i + " - " + arr[i]);     на место <span class="color-red">i</span> подставляется ключ/свойство 
};                                           каждую итерацию цикла
          i     arr[i]
     // ключ - значение
           0 - a
           1 - b
           2 - c
           3 - d

</code></pre>

                    <h3>for of</h3>

                    <pre><code>
let arr = [ "a", "b", "c", "d" ];

for (let i <span class="color-red">of</span> arr) { 
  console.log(i)                                    на место <span class="color-red">i</span> подставляется ключ/свойство                      
};                                                        каждую итерацию цикла
      // значения 
            a
            b
            c 
            d





</code></pre>

                    <pre><code>
arr.forEach((e) => console.log(e));  // a b c d

arr.map((e) => console.log(e))  // a b c d // новый массив

</code></pre>



                  </div>			



<div class="performance"><!-- Методы массивов -->

                    <h2>Методы массивов</h2>

                    <div class="performance">
                      <pre><code>
    unshift ┐       push ┐            стек
	    ▼            ▼
          [ + 0, 1, 2, 3 + ] 
            ▼            ▼
            └ shift      └ pop        очередь
</code></pre>
                    </div>

                    <h2>replace</h2>
                    <p>из числа с запятыми 3,45,666 можем получить 345666 использовав <code>.replace(/,/g " ")</code>
                    </p>

                    <details class="show-piece reverse">
                      <summary>Array.indexOf</summary>
                      Array.indexOf — ищет только 1 символ
                      String.indexOf — может искать строку больше 1 символа
                    </details>

                    <details class="show-piece reverse">
                      <summary>reverse - разворачивает</summary>
                      <p>изменяет исходный массив</p>

                      <pre>
  <code>
let a = [ ];

a[1] = 1;
b[2] = 2;

console.log(a + " : " + [0 in a, 1 in a, 2 in a]); // ,1,2, : false,true,true

a.reverse();

console.log(a + " : " + [0 in a, 1 in a, 2 in a]); // 2,1, : true,true,false
  </code>
</pre>
                    </details>

                    <details class="show-piece sort">
                      <summary>sort - сортирует</summary>
                      <p>изменяет исходный массив</p>
                      <p>принимает единственным аргументом функцию, сравнивающую элементы массива. Если функция
                        сравнения не
                        задана, то элементы
                        сортируются в лексикографическом порядке.</p>
                      <pre>
   <code>
 var a = ['d', 'b', 'a', 'e', 'c'];
 a.sort();
 alert(a); // a,b,c,d,e
   </code>
</pre>
                      <p>без переданной callback -функции, если сортировать числа, sort отсортирует их как строки,
                        а не как
                        числа.</p>
                      <pre>
   <code>
 let a = [4, 2, 10, 5, 30];
 a.sort(); // 10,2,30,4,5
   </code>
</pre>
                      <p>для сортировки чисел необходимо передать методу sort функцию сравнения двух чисел (a - b)
                        / (a + b)
                      </p>
                      <pre>
   <code>
 let arr = [ 3, 22, -10, 1, 7 ]

 без callback - функции
 arr.sort(); // [-10, 1, 22, 3, 7] - сортирует в лексикографическом порядке

 с функцией сравнения
 arr.sort((a-b) =&gt; a - b); // [-10, 1, 3, 7, 22] - сортирует по порядку
   </code>
</pre>
                    </details>

                    <details class="show-piece concat">
                      <summary>concat</summary>
                      <p>создаёт копию исходного массива, добавляя к нему переданные аргументы</p>
                      <pre>
   <code>
 Array.prototype.toString = function() {
   return '[' + this.join(,) + ']';
 };


 let a = [1,2,3];

 a.concat(4,5,6); //[1,2,3,4,5,6]

 a.concat([4,5],[6]); //[1,2,3,4,5,6]
   </code>
</pre>
                      <p>Однако дальше одного уровня concat аргументы-массивы не разворачивает</p>
                      <pre>
   <code>
 a.concat([4, [5], 6]); //[1,2,3,4,[5],6]
   </code>
</pre>
                      <p>пропуски как из исходного массива, так и из массивов-аргументов, сохраняются</p>
                      <pre>
   <code>
 let a = [1, , 3];

 console.log(a.concat([4, , 6])); // [1, , 3, 4, , 6]
   </code>
</pre>
                    </details>

                    <details class="show-piece slice">
                      <summary>slice - возвращает подмассив исходного массива</summary>
                      <p>slice(begin[, end])</p>
                      <p>возвращает подмассив исходного массива, начиная с индекса begin и заканчивая индексом end
                        - 1.</p>
                      <p>метод массива с помощью которого можно получить копию части или всего массива</p>
                      <p>Чтобы легче запомнить такую странную нумерацию, лучше считать, что передаются индексы не
                        элементов,
                        а "межэлементного пространства".</p>
                      <pre>
   <code>
 индексы элементов: 0 1 2 3 4 5 6 7 8
                   ^ ^ ^ ^ ^ ^ ^ ^ ^ ^
 индексы slice:    0 1 2 3 4 5 6 7 8 9
   </code>
</pre>
                      <p>становится понятно, что ar.slice(0, 1) вернёт только нулевой элемент, а slice(5, 9) — с
                        пятого по
                        восьмой элементы.</p>
                      <pre>
   <code>
let arr = [0, 1, 2, 3, 4, 5];

arr.slice(0, 2); // 0,1
arr.slice(4, 5); // 4
   </code>
</pre>
                      <p>Если второй аргумент является отрицательным числом, то отсчёт второго индекса идёт с конца
                        массива.
                      </p>
                      <pre>
  <code>
arr.slice(0, -2); // 0,1,2,3 
  </code>
</pre>
                      <p>Если же второй аргумент не передан вообще, то возвращается копия массива от begin до
                        конца.</p>
                      <pre>
   <code>
arr.slice(3); // 3,4,5
   </code>
</pre>
                    </details>


                    <details class="show-piece forEach">
                      <summary><code>forEach -- </code>применит функцию к каждому элементу</summary>
                      <pre><code>
let arr = [
	{id: 1, name: "a", age: 11},
	{id: 2, name: "b", age: 22},
	{id: 3, name: "c", age: 33}
]

arr.forEach(e => {
	let count = e.age + 1;
	let id = e.id;
	console.log(id + " - " + count);
		
		// 1 - 12
		// 2 - 23
		// 3 - 34
})
</code></pre>
                    </details>


                    <details class="show-piece some">
                      <summary><code>some -- </code>удовлетворяет ли выбранные элемент массива условию заданному в
                        передоваемой функции</summary>
                      <pre><code>
let arr = [
  {id: 1, name: "a", age: 11},
  {id: 2, name: "b", age: 22},
  {id: 3, name: "c", age: 33}
]

arr.some(e => e.age === 11); // true
arr.some(e => e.age === 12); // false 
arr.some(e => e.age === 33); // true

</code></pre>
                    </details>

                    <details class="show-piece reduce">
                      <summary><code>reduce -- </code>ринимает функцию у которой в качестве аргумента аккумулятор и
                        значение к каждому значению массива</summary>
                      <pre><code>
возвращает одно(общее) значение


const arrReduce = [ 1, 2, 3, 4, 5];

arrReduce.reduce((total, value) => total + value); // 15

</code></pre>
                    </details>

                    <details class="show-piece every">
                      <summary><code>every -- </code>все ли элементы массива удовлитворяют условию в переданной функции
                      </summary>
                      <pre><code>
const arrEveryFalse = [1, 2, 3];
const arrEveryTrye = [2, 2, 2];

arrEveryFalse.every(test => test === 2); // false
arrEveryTrye.every(test => test === 2); // true

</code></pre>
                    </details>

                    <details class="show-piece map">
                      <summary><code>map -- </code>вернет новый массив с результатом вызова для каждого элемента массива
                      </summary>
                      <pre><code>
const mapArrayOne = [1, 2, 3]; 
const mapArrayTwo = [5, 5, 5]; 

mapArrayOne.map(e => e + e); // [2, 4, 6] -- [1 + 1] [2 + 2] [3 + 3]
mapArrayTwo.map(e => e + e); // [10, 10, 10]

</code></pre>
                    </details>


                    <details class="show-piece flat">
                      <summary><code>flat -- </code>сгладит вложенные массивы в сплошной массив(работает только на одну
                        вложенность)</summary>
                      <pre><code>
const flatArray = [1, 2, ["a", "b", "c"], ["1", "2", "3"] ];

let flatArrayTwo = flatArray.flat();
console.log(flatArrayTwo);
</code></pre>
                    </details>


                    <details class="show-piece filter">
                      <summary><code>filter -- </code>вернет новый массив</summary>
                      <pre><code>
const filterArray = [
	{id: 1, name: "a"},
	{id: 2, name: "b"},
	{id: 3, name: "c"},
	{id: 4, name: "a"}	
]

filterArray.filter(e => e.name === "a" || e.id == 2); // вернет массив с тремя обьектами (в этом случае)

</code></pre>
                    </details>


                    <details class="show-piece find">
                      <summary><code>find -- </code>вернет элемент массива</summary>
                      <pre><code>
const findArray = [
	{id: 1, name: "a"},
	{id: 2, name: "b"},
	{id: 3, name: "c"}	
]

findArray.find(e => e.name === "a"); // Object {id: 1, name: "a"}
findArray.find(e => e.name === "d"); // undefined
</code></pre>
                    </details>

                    <details class="show-piece findindex">
                      <summary><code>findindex -- </code>вернет индекс</summary>
                      <pre><code>
const findIndexArray = [
	{id: 1, name: "a"},
	{id: 2, name: "b"},
	{id: 3, name: "c"}	
]

findIndexArray.findIndex(e => e.name === "a"); // 0
findIndexArray.findIndex(e => e.name === "d"); // -1

</code></pre>
                    </details>

                    <details class="show-piece sort">
                      <summary><code>sort</code></summary>
                      <pre><code>
const sortArray = ["c", 3, 2, "b", 1, "a"];

sortArray.sort(); // [1, 2, 3, "a", "b", "c"]

</code></pre>
                    </details>

                    <details class="show-piece concat">
                      <summary><code>concat -- </code>вернет новый массив </summary>
                      <pre><code>
const concatArrayOne = [1, 2, 3];
const concatArrayTwo = ["a", "b"];

concatArrayOne.concat(concatArrayTwo); // [1, 2, 3, "a", "b"]

</code></pre>
                    </details>


                    <details class="show-piece fill">
                      <summary><code>fill(значение, от, до); -- </code>заполнит диопазон индексов одинаковыми значениями
                      </summary>
                      <pre><code>
const fillArray = [1, 2, 3, 4, 5, 6, 7];

fillArray.fill("A", 1, 4); // [1, "A", "A", "A", 5, 6, 7]

</code></pre>
                    </details>


                    <details class="show-piece includes">
                      <summary><code>includes -- </code>вернет true если найдет значение</summary>
                      <pre><code>
const includesArray = [1, 2, "a"];

includesArray.includes(1);   // true
includesArray.includes(5);   // false
includesArray.includes("a"); // true

</code></pre>
                    </details>


                    <details class="show-piece reverse">
                      <summary><code>reverse</code></summary>
                      <pre><code>
const reverseArray = [1, 2, 3];

reverseArray.reverse(); //[3, 2, 1]
</code></pre>
                    </details>


                    <details class="show-piece delete">
                      <summary><code>delete -- </code>удаляет значение(индекс остается === undefined)</summary>
                      <pre><code>
let deleteArray = [1, 2, 3];

delete deleteArray[1];

deleteArray.length // длина массива осталась 3

deleteArray[0]; // 1
deleteArray[1]; // undefined
deleteArray[2]; // 3

</code></pre>
                    </details>

                    <details class="show-piece splice">
                      <summary><code>splice -- </code>удалить, добавить, заменить</summary>
                      <pre><code>
изменяет массив
вернет маасив из удаленных элементов

let spliceArray = ["a", "b", "c"];

spliceArray.splice(1, 1); // изменит массив и 
вернет элемент под индексом 1 = "b" 

     теперь массив такой ["a", "c"];

</code></pre>
                    </details>



                    <details class="show-piece ">
                      <summary><code></code></summary>
                      <pre><code>

</code></pre>
                    </details>



                  </div>






</section>

      </div>
    </main>

  </div>
  <script src="../main.js"></script>
</body>

</html>